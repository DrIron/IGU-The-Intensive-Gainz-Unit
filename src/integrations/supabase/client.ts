// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Extract project ref from URL for storage key
const PROJECT_REF = SUPABASE_URL?.match(/https:\/\/([^.]+)\./)?.[1] || 'ghotrbotrywonaejlppg';
const STORAGE_KEY = `sb-${PROJECT_REF}-auth-token`;

// Maximum time before we unblock operations waiting on auth initialization.
//
// Root cause: Supabase's GoTrueClient has a deadlock-prone initialization flow:
//   1. initialize() → _recoverAndRefresh() → _notifyAllSubscribers('SIGNED_IN')
//   2. _notifyAllSubscribers AWAITS all onAuthStateChange listener callbacks
//   3. If ANY listener calls getSession(), it does `await initializePromise`
//   4. initializePromise is waiting for step 1 to finish → circular deadlock
//
// This timeout breaks the deadlock by ensuring initializePromise resolves
// within INIT_TIMEOUT_MS, even if the initialization is stuck.
const INIT_TIMEOUT_MS = 5000;

/**
 * Custom lock function that bypasses Navigator LockManager entirely.
 *
 * Navigator LockManager is meant for cross-tab coordination, but it causes
 * deadlocks with Supabase's GoTrueClient because:
 * - The init function holds the lock while awaiting _notifyAllSubscribers
 * - Subscribers that call getSession() wait on initializePromise
 * - initializePromise waits for the init function → circular deadlock
 * - The lock is never released, blocking ALL subsequent operations
 *
 * By running fn() directly without a navigator lock, we trade cross-tab
 * token refresh coordination for app reliability. The worst case is a
 * concurrent token refresh across tabs, which is idempotent on the server.
 */
async function lockWithTimeout<R>(
  _name: string,
  _acquireTimeout: number,
  fn: () => Promise<R>
): Promise<R> {
  return await fn();
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'implicit',
    lock: lockWithTimeout,
  }
});

/**
 * Break the initializePromise deadlock.
 *
 * GoTrueClient.getSession() and all data queries internally do:
 *   await this.initializePromise
 * before proceeding. If initialization deadlocks (see INIT_TIMEOUT_MS comment),
 * every .from()/.rpc()/.getSession() call hangs forever.
 *
 * This patch races initializePromise against a timeout so that even if init
 * is deadlocked, the rest of the app unblocks. The session will still be
 * readable from localStorage — queries will attach the access token and work.
 */
const auth = supabase.auth as unknown as {
  initializePromise?: Promise<unknown>;
  lockAcquired?: boolean;
  pendingInLock?: Promise<unknown>[];
};
if (auth.initializePromise) {
  const original = auth.initializePromise;
  auth.initializePromise = Promise.race([
    original,
    new Promise((resolve) =>
      setTimeout(() => {
        console.warn(`[Supabase Client] initializePromise timed out after ${INIT_TIMEOUT_MS}ms — unblocking`);
        // Reset internal lock state so subsequent _acquireLock calls don't
        // chain onto the deadlocked pendingInLock queue.
        auth.lockAcquired = false;
        auth.pendingInLock = [];
        resolve({ error: null });
      }, INIT_TIMEOUT_MS)
    ),
  ]);
}

/**
 * Session initialization promise.
 *
 * Waits for the Supabase client to finish its internal initialization
 * (reading from localStorage and optionally refreshing the token).
 *
 * IMPORTANT: We do NOT call setSession() here. setSession() triggers
 * a network call to /auth/v1/token which puts the client in a "refreshing"
 * state that blocks ALL supabase.from() and supabase.rpc() queries.
 *
 * Instead, we let the client initialize naturally via getSession(),
 * which reads from localStorage and refreshes only if needed.
 */
let _sessionReadyResolve: () => void;
export const sessionReady: Promise<void> = new Promise((resolve) => {
  _sessionReadyResolve = resolve;
});

// Let the client initialize naturally — getSession reads from localStorage
// and triggers auto-refresh if the token is expired
supabase.auth.getSession().then(({ data, error }) => {
  if (error) {
    console.warn('[Supabase Client] getSession error:', error.message);
  } else if (data.session) {
    console.log('[Supabase Client] Session initialized via getSession');
  } else {
    console.log('[Supabase Client] No session found');
    // When initializePromise times out, getSession() returns null even though
    // a valid session exists in localStorage. The internal onAuthStateChange
    // listener that normally updates functions client headers never fires.
    // Recover the access token from localStorage and set it on the functions
    // client so that supabase.functions.invoke() attaches the correct JWT.
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed?.access_token) {
          console.log('[Supabase Client] Recovering functions auth from localStorage');
          supabase.functions.setAuth(parsed.access_token);
        }
      }
    } catch (e) {
      // Ignore — localStorage may be unavailable
    }
  }
  _sessionReadyResolve();
}).catch(() => {
  _sessionReadyResolve();
});

// Safety timeout — if getSession hangs (known issue), resolve after timeout
setTimeout(() => {
  _sessionReadyResolve();
}, INIT_TIMEOUT_MS);
